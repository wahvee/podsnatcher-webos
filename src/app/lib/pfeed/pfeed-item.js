/**
 * @constructor
 * @name PFeedItem
 * @description This is the base class of PFeedItem
 * @param itemElement {Element}
 */
var PFeedItem = Class.create({
	initialize: function(itemElement) {
		this.id = '';
		this.key = '';
		this.link = '';
		this.enclosure = '';
		this.enclosurePath = '';
		this.enclosureTicket = 0;
		this.enclosureType = '';
		this.enclosureLength = '';
		this.listened = false;
		this.currentTime = 0;

		if(Object.isElement(itemElement)) {
			// DO SOMETHING IF NEEDED
		}
		// Make sure key is set
		this.generateKey();
		// Make the events
		this.cacheProgress = Mojo.Event.make(
			PFeedItem.CacheProgress,
				{
					key: this.key,
					item: this,
					amountReceived: 0,
					amountTotal: 0,
					percentage: 0
				},
			Mojo.Controller.stageController.document
		);
		this.cacheError = Mojo.Event.make(PFeedItem.CacheError, {key: this.key, item: this}, Mojo.Controller.stageController.document);
		this.cacheComplete = Mojo.Event.make(PFeedItem.EnclosureCached, {key: this.key, item: this}, Mojo.Controller.stageController.document);
		this.cacheDeleted = Mojo.Event.make(PFeedItem.EnclosureDeleted, {key: this.key, item: this}, Mojo.Controller.stageController.document);
		this.cacheCanceled = Mojo.Event.make(PFeedItem.CacheCanceled, {key: this.key, item: this}, Mojo.Controller.stageController.document);
		this.updatedEvent = Mojo.Event.make(PFeedItem.PodcastItemUpdated, {key: this.key, item: this}, Mojo.Controller.stageController.document);
	},
	/**
	 * @function
	 * @name PFeedItem#generateKey
	 * @description Generate the unique id for the instance of PFeedItem.
	 * The key is generated by creating an MD5 hash of the the enclosure
	 * URL, the GUID of the item, or by the associated link of the instance.
	 */
	generateKey: function() {
		if(this.key.blank()) { this.key = (!this.enclosure.blank()) ? hex_md5(this.enclosure) : ''; }
		if(this.key.blank()) { this.key = (!this.id.blank()) ? hex_md5(this.id) : ''; }
		if(this.key.blank()) { this.key = (!this.link.blank()) ? hex_md5(this.link) : ''; }
	},
	/**
	 * @function
	 * @name PFeedItem#savePosition
	 * @description Store the playback of the instance of PFeedItem, used for
	 * resuming playback at a later time.
	 * @param newPosition {Number} The position in milliseconds.
	 */
	savePosition: function(newPosition) {
		var changed = this.currentTime !== newPosition;
		this.currentTime = newPosition;
		this.updatedEvent.key = this.key;
		if(changed) {
			Mojo.Controller.stageController.sendEventToCommanders(this.updatedEvent);
		}
	},
	/**
	 * @function
	 * @name PFeedItem#markAsOld
	 * @description This method sets the listened property to true.
	 * @see PFeedItem#listened
	 */
	markAsOld: function() {
		var changed = this.listened !== true;
		this.listened = true;
		this.updatedEvent.key = this.key;
		if(changed) {
			Mojo.Controller.stageController.sendEventToCommanders(this.updatedEvent);
		}
	},
	/**
	 * @function
	 * @name PFeedItem#markAsNew
	 * @description This method sets the listened property to false.
	 * @see PFeedItem#listened
	 */
	markAsNew: function() {
		var changed = this.listened !== false;
		this.listened = false;
		this.updatedEvent.key = this.key;
		if(changed) {
			Mojo.Controller.stageController.sendEventToCommanders(this.updatedEvent);
		}
	},
	/**
	 * @function
	 * @name PFeedItem#isCaching
	 * Check to see if the instance is currently downloading.
	 * @returns {boolean} True if downloading, false if not.
	 */
	isCaching: function() {
		return this.enclosureTicket !== 0 && !this.isEnclosureCached();
	},
	/**
	 * @function
	 * @name PFeedItem#isEnclosureCached
	 * Checks if the enclosure is stored locally.
	 * @returns {boolean} True if already stored locally, false otherwise.
	 */
	isEnclosureCached: function() {
		// Returns true if enclosure is stored locally
		return (this.enclosurePath !== undefined && !this.enclosurePath.blank());
	},
	/**
	 * @function
	 * @name PFeedItem#getEnclosure
	 * Returns either the cached enclosure path, or the URL of the enclosure.
	 * With a preference for the cached enclosure.
	 * @returns {String} Path to the enclosure.
	 */
	getEnclosure: function() {
		return ((this.isEnclosureCached()) ? this.enclosurePath : this.enclosure);
	},
	/**
	 * @function
	 * @name PFeedItem#removeCache
	 * Removes the already cached file associated with this instance.
	 * @param sendEvent {Boolean} Opitional parameter. Should events be triggered? Default to true.
	 */
	removeCache: function(sendEvent) {
		if(Object.isUndefined(sendEvent) || isNull(sendEvent)) {
			sendEvent = true;
		}
		var mojoController = Mojo.Controller.stageController.activeScene();
		if(this.enclosureTicket !== 0) {
			mojoController.serviceRequest('palm://com.palm.downloadmanager', {
				method: 'deleteDownloadedFile',
				parameters: {
					ticket: this.enclosureTicket
				},
				onSuccess: function(response) {
					if(response.returnValue) {
						this.enclosurePath = '';
						this.enclosureTicket = 0;
					}
					this.cacheDeleted.key = this.key;
					if(sendEvent) {
						Mojo.Controller.stageController.sendEventToCommanders(this.cacheDeleted);
					}
				}.bind(this),
				onFailure: function(response) {
					this.enclosurePath = '';
					this.enclosureTicket = 0;
					Mojo.Log.error("[PFeedItem.removeCache] (%i) Failed to delete ticket. %s", response.ticket, this.enclosurePath);
				}.bind(this)
			});
		}
	},
	/**
	 * @function
	 * @name PFeedItem#cacheEnclosure
	 * Performs the cache for this instance.
	 */
	cacheEnclosure: function() {
		//Mojo.Log.error("[PFeedItem.cacheEnclosure] %s", this.key);
		var mojoController = Mojo.Controller.stageController.activeScene();
		
		var cacheUpdate = function(response) {
			// If completed is false or undefined...still in the middle
			if(response.completed === undefined || !response.completed) {
					//Mojo.Log.info("[PFeedItem.cacheUpdate] %s, %s", response.amountReceived, response.amountTotal);
					// Used to tell if in progress
					this.enclosureTicket = response.ticket;
					// Calculate the event parameters
					var percent = (response.amountReceived / response.amountTotal) * 100;
					this.cacheProgress.key = this.key;
					this.cacheProgress.amountReceived = response.amountReceived;
					this.cacheProgress.amountTotal = response.amountTotal;
					this.cacheProgress.percentage = (isNaN(percent)) ? 0 : percent;
					// Send the progress event
					Mojo.Controller.stageController.sendEventToCommanders(this.cacheProgress);
	
			// Otherwise, we are completed and everything is ok.
			} else if(response.completed && response.completionStatusCode == 200) {
				this.cacheComplete.key = this.key;
				this.cacheProgress.key = this.key;
				this.cacheProgress.amountReceived = 0;
				this.cacheProgress.amountTotal = 0;
				this.cacheProgress.percentage = 0;
				this.enclosurePath = response.target;
				this.enclosureTicket = response.ticket;
				Mojo.Controller.stageController.sendEventToCommanders(this.cacheComplete);
			} else {
				Mojo.Log.error("[PFeedItem.cacheUpdate] Something un-expected happened.");
				Object.extend(this.cacheError, response);
				Mojo.Controller.stageController.sendEventToCommanders(this.cacheError);
			}			
		}
		
		if(this.enclosure !== undefined && !this.enclosure.blank()) {
			mojoController.serviceRequest('palm://com.palm.downloadmanager', {
				method: 'download',
				parameters: {
					target: this.enclosure,
					mime: (this.enclosureType !== undefined && !this.enclosureType.blank()) ? this.enclosureType : '',
					targetDir: '/media/internal/PodSnatcher/downloads',
					keepFilenameOnRedirect: true,
					subscribe: true
				},
				onSuccess: cacheUpdate.bind(this),
				onFailure: function(error) {
					Mojo.Log.logProperties(error);
					Mojo.Log.error("[PFeedItem.cacheEnclosure] Failed downloading enclosure.");
					this.cacheError.key = this.key;
					Mojo.Controller.stageController.sendEventToCommanders(this.cacheError);
				}.bind(this)
			});
		} else {
			Mojo.Log.error("[PFeedItem.cacheEnclosure] There is no enclosure path. What am I supposed to do?");
			Mojo.Controller.stageController.sendEventToCommanders(this.cacheError);
		}
	},
	/**
	 * @function
	 * @name PFeedItem#cancelCache
	 * If a cache is currently in progress it stops the cache from continuing.
	 */
	cancelCache: function() {
		//Mojo.Log.error("[PFeedItem.cancelCache] %s", this.key);
		var mojoController = Mojo.Controller.stageController.activeScene();
		mojoController.serviceRequest('palm://com.palm.downloadmanager/', {
			method: 'cancelDownload',
			parameters: {
				"ticket" : this.enclosureTicket
			},
			onSuccess : function (response) {
				Mojo.Log.info("[PFeedItem.cancelCache] %i canceled.", this.enclosureTicket);
				if(response.returnValue) {
					this.enclosureTicket = 0;
					this.cacheCanceled.key = this.key;
					Mojo.Controller.stageController.sendEventToCommanders(this.cacheCanceled);
				}
			}.bind(this),
			onFailure : function (error){
				this.enclosureTicket = 0;
				Mojo.Log.error("[PFeedItem.cancelCache] %s", error.message);
			}.bind(this)
		});
	},
	/**
	 * @function
	 * @name PFeedItem#getTitle
	 * Returns the title of the item. Currently, this is just the title from the XML.
	 * At some point in the future it will return a generated or user defined
	 * title.
	 * @returns {String} Returns the title of the item.
	 */
	getTitle: function() {
		return this.title;
	},
	/**
	 * @function
	 * @name PFeedItem#getStatusIndicator
	 * Calculates what the current status of the item is. The function will
	 * return a status from PFeedItem.Status.
	 * @returns A string that is a status from PFeedItem.Status.
	 */
	getStatusIndicator: function() {
		if(this.listened === false && this.currentTime === 0 && !this.isEnclosureCached()) {
			if(this.isCaching()) {
				return PFeedItem.Status.NewCaching;
			} else {
				return PFeedItem.Status.New;
			}
		} else if(this.listened === false && this.currentTime === 0  && this.isEnclosureCached()) {
			return PFeedItem.Status.NewCached;
		} else if(this.listened === false && this.currentTime !== 0 && !this.isEnclosureCached()) {
			if(this.isCaching()) {
				return PFeedItem.Status.InProgressCaching;
			} else {
				return PFeedItem.Status.InProgress;
			}
		} else if(this.listened === false && this.currentTime !== 0 && this.isEnclosureCached()) {
			return PFeedItem.Status.InProgressCached;
		} else if(this.listened && this.isEnclosureCached()) {
			return PFeedItem.Status.ListenedCached;
		} else {
			if(this.isCaching()) {
				return PFeedItem.Status.ListenedCaching;
			} else {
				return PFeedItem.Status.Listened;
			}
		}
	},
	/**
	 * @function
	 * @name PFeedItem#copy
	 * Extend this instance of PFeedItem with the object being passed in.
	 * Only, properties that exist in the PFeedItem and reference object
	 * will be added.
	 * @param objToExtendFrom {Object | PFeedItem} The object that will have it's properties copied.
	 */
	copy: function(objToExtendFrom) {
		// Get all the properties from this
		var arrKeys = Object.keys(this);
		// Go through all of the keys of this instance
		arrKeys.each(function(key) {
			// Check to make sure:
			//    it is not undefined and is not null
			//    and it is a String and not blank
			//    or it is a Number
			//    or it is Boolean
			if(!Object.isUndefined(objToExtendFrom[key])
				&& !isNull(objToExtendFrom[key])
				&& ((Object.isString(objToExtendFrom[key]) && !objToExtendFrom[key].blank())
					|| Object.isNumber(objToExtendFrom[key])
					|| Object.isBoolean(objToExtendFrom[key]))
			) {
				if(Object.isBoolean(this[key])) {
					this[key] = (objToExtendFrom[key] === 'true') ? true : false;
				} else if(this[key] instanceof Date) {
					this[key] = new Date(objToExtendFrom[key]);
				} else {
					this[key] = objToExtendFrom[key];
				}
			}
		}, this);
	},
	/**
	 * @function
	 * @name PFeedItem#isValidMIME
	 * Checks that the MIME type that is specified is a valid one. The MIME types that
	 * would be found valid are found on this Wiki page:
	 * http://en.wikipedia.org/wiki/Mime_type for either the Audio or Video types.
	 * @returns {Boolean} True if the MIME type is detected here, false otherwise.
	 */
	isValidMIME: function() {
		var validTypes = [
			'audio/basic',
			'audio/mp4',
			'audio/mpeg',
			'audio/ogg',
			'audio/vorbis',
			'audio/x-ms-wma',
			'audio/x-ms-wax',
			'audio/vnd.rn-realaudio',
			'audio/vnd.wave',
			'video/mpeg',
			'video/mp4',
			'video/ogg',
			'video/quicktime',
			'video/x-ms-wmv'
		];
		// Determines if the type is within the valid types array
		return validTypes.include(this.enclosureType);
	},
	/**
	 * @function
	 * @name PFeedItem#inferMIME
	 * @description
	 * Attempts to infer a MIME type based on the file extension. This inference
	 * is only attempted in the event that the MIME type already stored is not
	 * considered valid.
	 * @see PFeedItem#isValidMIME
	 */
	inferMIME: function() {
		// Check to see if the MIME type is recognized
		if(!this.isValidMIME()) {
			var ext = this.enclosure.getExtension();
			Mojo.Log.info("[PFeedItem.generateMIME] We have an invalid MIME type. Trying to infer one from the extension: %s", ext);
			// Check to see if we recognize the file extension
			switch(ext.toLowerCase()) {
				case 'mp3':
					this.enclosureType = 'audio/mpeg';
					break;
				case 'm4v':
					this.enclosureType = 'video/mp4';
					break;
				default:
					Mojo.Log.info("[PFeedItem.generateMIME] Unfortunately, cannot infer anything. Leaving as found.");
					break;
			}
		}
	},
	/**
	 * @private
	 * @function
	 * @name PFeedItem#nsResolver
	 * @description
	 * This is used to resolve Namespaces within XML documents.
	 */
	nsResolver: function(prefix) {
		prefix = prefix.toLowerCase();
		var ns = {
			"rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
			"atom": "http://www.w3.org/2005/Atom",
			"itunes": "http://www.itunes.com/dtds/podcast-1.0.dtd",
			"podcastSearch": "http://digitalpodcast.com/podcastsearchservice/output_specs.html",
			"media": "http://search.yahoo.com/mrss/"
		};
		return ns[prefix] || null;
	}
});

PFeedItem.CacheCanceled = 'onEnclosureCacheCanceled';
PFeedItem.CacheProgress = 'onEnclosureCacheProgress';
PFeedItem.CacheError = 'onEnclosureCacheError';
PFeedItem.EnclosureCached = 'onEnclosureCached';
PFeedItem.EnclosureDeleted = 'onEnclosureDeleted';
PFeedItem.PodcastItemUpdated = 'onPodcastChange';


PFeedItem.Status = {};
PFeedItem.Status.New = 'new';
PFeedItem.Status.NewCaching = 'newCaching';
PFeedItem.Status.NewCached = 'newCached';
PFeedItem.Status.InProgress = 'inProgress';
PFeedItem.Status.InProgressCaching = 'inProgressCaching';
PFeedItem.Status.InProgressCached = 'inProgressCached';
PFeedItem.Status.Listened = 'listened';
PFeedItem.Status.ListenedCaching = 'listenedCaching';
PFeedItem.Status.ListenedCached = 'listenedCached';

/**
 * @static
 * @function
 * @name PFeedItem#simpleObject
 * Converts the instance of PFeedItem to a simple Object. Basically, strips every
 * property that is not a String, Number or Boolean value. Only keeps values that
 * are returned.
 * @param {PFeedItem} The instance to be made into a simple object.
 * @returns {Object} The simple object created from the passed in instance.
 */
PFeedItem.simpleObject = function(instance) {
	if(instance instanceof PFeedItem) {
		var copy = Object.clone(instance);
		var arrKeys = Object.keys(copy);
		arrKeys.each(function(key) {
			if(!(Object.isString(copy[key]) || Object.isNumber(copy[key]) || Object.isBoolean(copy[key])) ||
					(Object.isString(copy[key]) && copy[key].blank())) {
				delete copy[key];
			}
		});
		return copy;
	}
	return undefined;
};
